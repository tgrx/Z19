# Функции

## Введение

Функция - это такой же тип данных,
как и любой другой типа чисел, строк и др.

Все функции в Python являются [first-class citizens](https://en.wikipedia.org/wiki/First-class_citizen):
иначе говоря, полноценным типом данных.
Функции можно:
- передавать в другие функции
- возвращать как результат
- присваивать переменным
- сохранять в коллекции

Функции бывают именованные:

```python
def is_leap(year: int) -> bool:
    """Проверяет, високосный ли год"""
    
    if year % 400 == 0:
        return True

    if year % 100 == 0:
        return False

    if year % 4 == 0:
        return True

    return False
```

И безымянные (лямбда-функции):

```python
lambda year: (year % 400 == 0) or ((year % 100 != 0) and (year % 4 == 0))
```

Именованная функция в примере выше состоит из:
- имени: "is_leap"
- списка аргументов: `(year,)`
- документации (docstring): самая первая строка `"""..."""` после определения - доступна по `help(is_leap)`
- собственно кода, инструкций - всё, что после определения и docstring

Лямбда-функция состоит из:
- списка аргументов: `(year,)`
- собственно кода: всё, что после списка аргументов и двоеточия

Чтобы из лямбда-функции сделать именованную, достаточно этот объект именовать: связать его с переменной:

```python

is_leap = lambda year: (year % 400 == 0) or ((year % 100 != 0) and (year % 4 == 0))

is_leap(1600)  # True
```

## Аргументы функций

Функции можно вызывать (исполнять), используя `()` и имя функции:

```python
str(10)
```

В данном примере, "str" - имя, "10" - аргумент.

Из функции можно возвращать результат:

```python
def f(a, b):
    return a * b

x = f("a", 5)  # "x" указывает на строку "aaaaa"
```

Если из функции ничего не возвращать явно - она неявно будет возвращать `None`:

```python
def f1():
    return None

def f2():
    return

def f3():
    pass

def f4():
    ...

functions = [f1, f2, f3, f4]

for f in functions:
    print(f() is None)  # будет четыре True
```

Аргументы в функцию можно передавать по порядку:

```
def f(x, y): return x / y

f(1, 0)
```

По имени:

```
def f(x, y): return x / y

f(y=1, x=0)
```

Сразу все, кортежем (списком):

```
def f(x, y): return x / y

a = (0, 1)

f(*a)
```

Сразу все, поимённо — словарём:

```
def f(x, y): return x / y

k = {
    "x": 0,
    "y": 1,
}

f(**k)
```

## Пространства имён и видимость переменных

Переменная - это имя, с которым ассоциированы реальные данные.

Запись 

```python
x = 1
```

аналогична записи

```python
{
    "x": 1,
}
```

и такого плана словари (dict) хранятся в определённом месте: `globals()`, `locals()`, `builtins()`.

Область видимости — это часть кода, в которой переменная видна.
Области вкладываются: чем глобальнее переменная, тем больше она видна.

Пакеты, модули, классы, функции - все они имеют свои области видимости.

Например:

```python
# lesson.py

# "глобальная", на уровне модуля lesson.py, в другх модулях не видна
x = 1

# "f" в данном случае - тоже переменная, видна только в этом модуле
def f():
    # "y" - "локальная", видна только внутри функции "f"
    y = 2
    print(x, y)  # хоть "x" в самой функции не задана, она берётся с уровня выше

f()  # "f" видна, можем использовать: например, вызвать как функцию
print(y)  # "y" из "f" не видна, в модуле не определена - NameError
```

NB: аргументы функции видны только внутри неё, хотя значение своё обретают в момент её вызова.

### Аналогия

Переменные — это как имена в вашем списке контактов в телефоне.
Реальные объекты — люди — одни и те же,
но каждый у себя в своём пространстве имён — списке контактов — называет их по своему.
Контакт не содержит внутри себя человека, а содержит цифры, на которые можно набрать и человечка найти.
Аналогично и переменные не содержат внутри себя никаких данных, а только "цифры" (адрес в памяти), по которым
к самим данным можно обратиться.

Отсюда же следует, что несколько переменных могут указывать на на одни и те же данные:

```python
x = y = z = []
x.append(1)
print(y)  # [1]
print(z)  # [1]
```

## Импорты

Чтобы вы могли позвонить человеку из чужого списка контактов, этот контакт нужно себе добавить.
Чтобы вы смогли получить доступ к данным, на которые ссылается переменная из другой области видимости,
эту переменную нужно себе импортировать.

```python
from math import pi
from decimal import Decimal
```

Допустим, есть два файла `lesson1.py` и `lesson2.py`. В первом определена функция `f`.

Чтобы использовать её во втором файле, нужно её импортировать:

```python
# lesson1.py

def f():
    print(f"{f.__module__}.{f.__name__}")
```

```python
# lesson2.py

# 1
from lesson1 import f

f()
```

если выполнить код из модуля `lesson2`: `python lesson2.py` - по увидим `"lesson1.f"`.

Способы импорта: [документация](https://docs.python.org/3/reference/import.html).

### Пакеты

Пакеты - это коллекции из модулей и других пакетов.

Реализуется пакет как папка с файлом `__init__.py` в ней. Пример:

```
Z19
|
+ homeworks/
    |
    + __init__.py
    |
    + alexander/
    |   |
    |   + __init__.py
    |   |
    |   + lesson1/
    |   |   |
    |   |   + __init__.py
    |   |   |
    |   |   + task.py
    |   |       def f(): print(f"{f.__module__}.{f.__name__}"
    |   |
    |   + lesson2.py
    |       def g(): print("g")
    |
    + alina/
        |
        + lesson3.py
            from homeworks.alexander.lesson1.task import f
            from homeworks.alexander.lesson2 import g
            f()
            g()
```

Теперь, в примере выше, если, находясь в папке `Z19`, вызвать Питон: `python -m homeworks.alina.lesson3`, то...

[Документация](https://docs.python.org/3/tutorial/modules.html)

## Управление

Документация:
1. [исполнение](https://docs.python.org/3/reference/executionmodel.html)
1. команды
    1. [простые](https://docs.python.org/3/reference/simple_stmts.html)
    1. [составные](https://docs.python.org/3/reference/compound_stmts.html)
