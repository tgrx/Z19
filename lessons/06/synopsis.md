# ООП

Наверное, самая популярная парадигма (более 99%)
в современном программировании.

Википедия:
[ООП](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).

Сто тысяч миллионов видео, курсов и ссылок
в [интернете](https://www.google.com/search?q=ООП).

Суть: объединяем и данные, и способ обработки этих данных
в одну сущность.

В Python такая сущность называется
["класс"](https://docs.python.org/3/tutorial/classes.html).

А "данные" и "способ обработки этих данных" —
когда они внутри класса — имею название: "атрибуты".

## Пример

Напишем свой собственный класс.

"Данные" — пусть это будет шаблонная строка
с фальшивым приветствием.

А "способом обработки этих данных"
пусть будет заполнение этой шаблонной строки
каким-то именем.

```python
class Noname:
    # данные:
    data = "Привет, {username}! Рад знакомству!"

    # способ, который с данными что-то делает:
    def say_hello(self, tykto: str) -> str:
        return self.data.format(username=tykto)
```
 
Прекрасный и функциональный класс!

### Что это даёт и как этим пользоваться

Пользоваться классами очень просто:

 ```python
n = Noname()
r = n.say_hello("анон")
print(r)
# видим: "Привет, анон! Рад знакомству!"
```

## Пространство имён

Класс задаёт, кроме всего прочего, пространство имён.
Это означает, что:
1. атрибуты класса видны классу, а внешнему миру нет:
    ```python
    print(data)  # NameError
    say_hello("xxx")  # NameError
    ```
1. если нужно во внешнем мире получить доступ к атрибуту класса, используется синтаксис "через точку"
    ```python
    class Hater:
        data = "Ненавижу тебя, {username}!"

    print(Noname.data)  # "Привет, {username}! Рад знакомству!"
    Noname.say_hello(Hater, "анон")  # "Ненавижу тебя, анон!"
    ```

## Тип

Класс определяет, кроме всего прочего, новый тип.

Условно, класс == тип.

```python
class Anon:
    def say_name(self):
        return "Anonim legion"

class Deanon:
    def say_hello(self):
        return "127.0.0.1"

def call(can_say_hello):
    can_say_hello.say_hello()
```

функция `call` расчитывает на то,
что переданный ей аргумент умеет здороваться.
Иначе говоря, имеет атрибут `"say_hello"`,
который можно вызвать как функцию.

Что ж, оба класса подходят:

```python
anon = Anon()
deanon = Deanon()

call(anon)
call(deanon)
```

## Объекты

## Атрибуты объектов, классов и вообще

## Наследование

## Специальные методы

## Перегрузка

## Проблемы наследования и MRO

MRO: [Хабр](https://habr.com/ru/post/62203/)

## Создание классов

## Метаклассы
