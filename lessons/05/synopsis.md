# Управление

## Условия

Допустим, задача требует того, чтобы при одном условии
выполнялся один код, а при другом — другой, а если
никакое условие не подходит — то вообще третий.

Такая задача решается с помощью конструкции `if/elif/else`:

```python
if predicate:
    action
```

Означает: если "predicate" окажется равен `True` — то
будет выполняться блок кода "action".

Пример:

```python
if input("печатать?").lower() == "yes":
    print("печатаю")

print("всегда делаю")
```

Если такое запустить, функция `input` 
спросит пользователя "печатать?" и будет ждать его ввода.
Если пользователь введёт `yEs`,
то `input` вернёт строку `"yEs"`,
`"yEs".lower()` вернёт `"yes"`,
операция сравнения `"yes" == "yes"` вернёт `True`,
и код `print("печатаю")` выполнится.

В любом другом случае код `print("печатаю")` не выполнится.

Код `print("всегда делаю")` всегда выполнится, безусловно:
т.к. он находится вне контекста условия.

Если вариантов несколько, то их можно перебирать с помощью `if/elif`:

```python
choice = input("быть или не быть? ")

if choice == "быть":
    print("быть")
elif choice == "не быть":
    print("не быть")
```

А если условия противоречащие,
то можно использовать `if/else`:

```python
from random import randint

s = "x" if randint(0, 1) else ""

if s:
    print("строка не пустая")
else:
    print("строка пустая")
```

Строка (и коллекции вообще и типы вообще)
не может быть одновременно и пустой и непустой.
Поэтому, можно, конечно, писать и так:

```python
if s:
    print("строка не пустая")
elif not s:
    print("строка пустая")
```

-- но не нужно.

NB: обратите внимание на синтаксис `a if p else b`:

```python
abs_x = x if x >= 0 else -x
```

## Циклы

### while: продолжаем, пока можно

Синтаксис:

```python
while true:
    stay_true()
```

Это означает: пока `true` равно `True`,
будет выполняться `do()`.

NB: большие или маленькие буквы —
в Python это имеет значение!

Пример — как победить "умного" пользователя:

```python
while input("введи правильный вариант: ") != 88:
    print("я сказал, правильный!") 
```

Цикл можно прервать командой `break`:

```python
while not False:
    v = input("введи правильный вариант: ")
    if v.isdigit() and 1 < int(v) < 10:
        print("повезло")
        break
```

Если надо исполнение цикла прекратить,
но сам цикл продолжить — как бы "вернуться в начало" — то
используется команда `continue`:

```python
while not not True:
    v = input("введи правильный вариант: ")
    if v.isdigit() and int(v) < 10:
        print("повезло")
        break
    elif int(v) < 20:
        continue  # молча...

    print("не повезло!")
```

На числах 0..9 повезёт,
на 20+ - не повезёт (но об этом скажут), а вот если 10..19 — то
вернут в начало и спросят за правильный вариант.

### for: перебираем элементы в коллекции

Элементы.

В коллекции.

Задача: 10 раз напечатать "for перебирает элементы в коллекции".

Так не сработает: `10` — это число: атом, а не коллекция: 
```python
for i in 10:
    print("напечатаю-ка ещё 20 раз!")
```

а вот так — пожалуйста:

```python
for i in "0123456789":
    print(f"#{i}: строка - это тоже коллекция")
```

Преждевременные выходы из цикла те же самые: `break`/`continue`:

```python
for n in {6,5,7,4,8,3,9,2,0,1}:
    if n == 3:
        print("foo")
        continue

    if n == 5:
        print("bar")
        continue

    if n == 3 and n == 5:
        break
        print("хорошо, что вы этого не увидите")
```


#### Для продвинутых

Под капотом работу этого цикла можно описать следующим образом:

`for element in iterable`

В этом синтаксисе `iterable` означает "итерируемое": "то, что можно итерировать".

А "итерируемое" — это какое-то нечто,
которое умеет в операцию "вернуть следующий элемент".

Причём, каким именно следующим будет "следующий" —
это дело "итерируемого".

Например, кортежи-списки-строки "следующим"
возвращают по порядку, начиная с первого.

Множества и словари (свои ключи) —
в каком-то своём рандомном порядке.

Строго говоря, всегда можно создать своё собственное нечто,
и если у него будет метод `__iter__`,
который будет создавать итератор — другое нечто,
у которого будет метод `__next__`,
который будет или возвращать что-то
(не важно, что - важно, что), или кидать `StopIteration`,
когда посчитает, что хорош уже — тогда это нечто можно будет
использовать в `for`.

Пример: бесконечный цикл:

```python
class Infiniti:
    def __iter__(self):
        return self
    def __next__(self):
        return False  # что угодно

for i in Infiniti():
    print(i)  # печатает False до бесконечности
```

можно добавить ограничители:

```python
class Range:
    def __init__(self, stop):
        self.start = self.current = 0
        self.stop = stop
    def __iter__(self):
        self.current = self.start
        return self
    def __next__(self):
        if self.current >= self.stop:
            raise StopIteration
        c, self.current = self.current, self.current + 1 
        return c

for i in Range(10):
    print(i)  # ну, вы понели
```

### Полезности для работы с коллекциями

`range(n)` - лениво создаёт коллекцию с элементами от 0 до n. [читать](https://pynative.com/python-range-function/)

`sorted(c)` - создаёт список с отсортированными значениями из коллекции c. [читать](https://realpython.com/python-sort/)

`reversed(c)` - лениво создаёт коллекцию с элементами, в обратном порядке идущими из коллекции c. [читать](https://www.programiz.com/python-programming/methods/built-in/reversed)

`filter(p, c)` - лениво применяет [предикат](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%B8%D0%BA%D0%B0%D1%82) p к каждому элементу коллекции c и возвращает только те, для которых предикат вычисляется как True. [читать](https://www.programiz.com/python-programming/methods/built-in/filter)
