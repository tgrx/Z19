# Задания

## Уровень 1

1. Прочитать конспект с уроков 3~5

**следующие уровни требуют работы с Git**

Процесс:
1. создаёте новую ветку
2. в свою рабочую папку добавляете файл - один! единственный! который называется! - **lesson05.py** — и только так! никак иначе!
3. в нём создаёте функции из уровней ниже
    1. вызывать ничего не надо! только объявить!
    1. вызывайте, если хотите, в ipython или в других скриптах
4. коммитите
5. пушуете ветку
6. на GitHub создаёте Pull request
7. во вкладке "Conversation" смотрите, как упал билд
    1. смотрите, почему ваш код не работает
    1. чините
    1. повторяете пункты 4~5

Условия:
1. не использовать хитрости типа слайсов
1. не использовать стандартные функции


## Уровень 2

Создать функцию `Reversed`
1. её единственный аргумент — кортеж или список или строка
2. функция возвращает список из элементов коллекции-аргумента, но которые в обратном порядке

Пример:

```python
Reversed([]) == []
Reversed((3,2,1)) == [1, 2, 3]
Reversed("abc") == ["c", "b", "a"]
```

## Уровень 3

Создать функцию `Sorted`
1. её единственный аргумент — любая коллекция
2. функция возвращает список (`r`) из элементов коллекции-аргумента, которые отсортированы по возрастанию: `r[0] <= r[1]`
3. алгоритм сортировки — любой, который сможете реализовать (на собесах могут предложить написать в уголке на листочке бумажки алгоритм пузырьковой сортировки)

Пример:

```python
Sorted([]) == []
Sorted((3,1,2)) == [1, 2, 3]
Sorted("zxy") == ["x", "y", "z"]
Sorted({3,1,1,2}) == [1, 2, 3]
```

## Уровень 4

Создать функцию `Filter`.
1. у неё два аргумента
    1. первый аргумент — предикат (функция)
    1. второй аргумент - любая коллекция
2. функция возвращает список (`r`) из элементов коллекции-аргумента, для которых предикат истинен

Пример:

```python
Filter(bool, [0,1,2]) == [1, 2]
Filter(bool, []) == []

def kek(s):
    return "kek" in s

Filter(
    kek,
    ["ke", "kek", "keke", "ekek", "lul"],
) == ["kek", "keke", "ekek"]
```

## Уровень 5

Аналогично уровню 2, но чтобы функция возвращала коллекцию того же типа, который имеет аргумент:

Функцию назвать: `TypedReversed`

Пример:

```python
TypedReversed([]) == []
TypedReversed((3,2,1)) == (1, 2, 3)
TypedReversed("aacb") == "bcaa"
```

## Уровень 6

Аналогично уровню 2, но чтобы функция возвращала итератор:

Функцию назвать: `LazyReversed`

Пример:

```python
LazyReversed([]) == ?  # некий итератор
LazyReversed((3,2,1)) == ?  # некий итератор
LazyReversed("aacb") == ?  # некий итератор

list(LazyReversed([])) == []
tuple(LazyReversed([3,2,1])) == (1, 2, 3)
```

## Уровень 7

Взять функцию `Range` - ну, не функцию, но — из конспекта — и улучшить её так,
чтобы она работала как стандартная `range`.

Пример:
```python
list(Range(3)) == [0, 1, 2]
tuple(Range(-1, 2)) == (–1, 0, 1)
tuple(Range(0, -10, -2)) == (0, -2, -4, -6, -8)
list(Range(0, -10, 3)) == []
2 in Range(10, -10, -1) == True
```

## Уровень 8

Создать функцию `DateRange`, которая работает как `range`, но только для дат:

```python
from datetime import date as d, timedelta as t

today = d.today()
tomorrow = today + t(days=1)
next_week = today + t(days=7)

tomorrow in DateRange(today, next_week) == True
```
