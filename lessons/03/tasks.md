# Задания

## Уровень 1

1. Прочитать конспект
1. Поэкспериментировать с типами данных
1. Прислать мне вопросы, если что-то непонятно
    - иначе автоматически считаю, что материал усвоен

---

**Дальше уровни требуют Git: работу нужно добавить в свою папку в homeworks,
закоммитить и сделайте пулл реквест - стандартный флоу,
как в занятии 1 и 2.
Свою ветку создаёте от ветки `master`,
и pull request в неё же.**

---

## Уровень 2

Измерьте эффективность операций над типами данных.
1. Замерьте, как быстро выполняется сложение
    1. для int: `5**7` и `7**5`
    1. для int: `17**19` и `19**17`
    1. для float: `1e30` и `1e-30`
    1. для complex: `1+2j` и `2-1j`
    1. для Decimal: `"0.33"` и `"1.66"`
    1. для Decimal: `5**7` и `7**5`
    1. для Decimal: `17**19` и `19**17`
1. Замерьте, как быстро выполняется умножение
    1. для int: `5**7` и `7**5`
    1. для int: `17**19` и `19**17`
    1. для float: `1e30` и `1e-30`
    1. для complex: `1+2j` и `2-1j`
    1. для Decimal: `"0.33"` и `"1.66"`
    1. для Decimal: `5**7` и `7**5`
    1. для Decimal: `17**19` и `19**17`
1. Замерьте, как быстро выполняется деление
    1. для int: `5**7` и `7**5`
    1. для int: `17**19` и `19**17`
    1. для float: `1e30` и `1e-30`
    1. для complex: `1+2j` и `2-1j`
    1. для Decimal: `"0.33"` и `"1.66"`
    1. для Decimal: `5**7` и `7**5`
    1. для Decimal: `17**19` и `19**17`
1. Замерьте, как быстро выполняется поиск подстроки в строке `s = "ab" * 10000 + "c"`:
    1. `"a"`
    1. `"b"`
    1. `"c"`
    1. `"ab"`
    1. `"ba"`
    1. `"bc"`
    1. `"ac"`
    1. `"ababababababababababc"`
1. Замерьте, как быстро выполняется поиск
    элементов `0`, `9999` и `10000` в коллекциях:
    1. в списке `L = [i for i in range(10000)]`
    1. в кортеже `T = tuple(i for i in range(10000))`
    1. во множестве `S = {i for i in range(10000)}`
    1. в словаре `D = {i:i for i in range(10000)}`
    1. в рэнже `R = range(10000)`

Создайте файл с результатами исследования.

## Уровень 3

Сделать уровень 2.

Посчитать разницу скоростей в процентном соотношении,
описать предположения, почему всё так.

## Уровень 4

Реализовать функцию Аккермана.
Найти граничные значения,
после которых компьютер взрывается -
или хотя бы Python падает с ошибками.

## Уровень 5

Создайте несколько функций, которые бы работали со списком как с очередью [FIFO](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics):

```python
def enqueue(l, e):
    """ добавляет элемент в конец очереди """

def dequeue(l):
    """
    вынимает элемент из начала очереди и возвращает его
    если очередь пуста - возвращается None
    """
```

Вставьте этот код в конец файла, где реализованы эти функции,
скормите файл Питону - всё должно выполниться без ошибок:

```python
if __name__ == "__main__":
    x = []
    assert dequeue(x) is None
    assert enqueue(x, 1) is None
    assert enqueue(x, 2) is None
    assert dequeue(x) == 1
    assert enqueue(x, 3) is None
    assert dequeue(x) == 2
    assert dequeue(x) == 3
    assert dequeue(x) is None
    assert x == []
```

## Уровень 6

Создайте несколько функций, которые бы работали со словарём (`dict`) как с очередью [FIFO](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics) с приоритетами:

```python
def enqueue(l, p, e):
    """ добавляет элемент e в конец очереди l с приоритетом p """

def dequeue(l):
    """
    вынимает элемент из начала очереди и возвращает его
    если очередь пуста - возвращается None
    элементы возвращаются согласно приоритету
    """
```

Вставьте этот код в конец файла, где реализованы эти функции,
скормите файл Питону - всё должно выполниться без ошибок:

```python
if __name__ == "__main__":
    x = {}
    assert dequeue(x) is None
    assert enqueue(x, 1, "a") is None
    assert enqueue(x, 1, "b") is None
    assert enqueue(x, 2, "aa") is None
    assert dequeue(x) == "aa"
    assert enqueue(x, 1, "c") is None
    assert enqueue(x, 3, "aaa") is None
    assert enqueue(x, 3, "bbb") is None
    assert enqueue(x, 2, "bb") is None
    assert dequeue(x) == "aaa"
    assert dequeue(x) == "bbb"
    assert dequeue(x) == "bb"
    assert dequeue(x) == "a"
    assert dequeue(x) == "b"
    assert dequeue(x) == "c"
    assert dequeue(x) is None
    assert x == {}
```
